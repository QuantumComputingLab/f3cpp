#include "qclab/QCircuit.hpp"
#include "f3c/SquareCircuit.hpp"
#include "f3c/TriangleCircuit.hpp"
#include "f3c/parameters.hpp"
#include "f3c/qgates/functors.hpp"
#include <string>
#include <fstream>

template <typename P>
std::string printTimestep( const int i ,
                           const P* hx , const P* hy , const P* hz ,
                           const P* Jx , const P* Jy , const P* Jz ,
                           const double dt = -1 ) {

  std::stringstream stream ;
  stream << "timestep " << i+1 << ": " ;
  int c = 0 ;
  if ( (*hx)[i] != 0 ) {
    stream << "hx = " << (*hx)[i] ;
    c++ ;
  }
  if ( (*hy)[i] != 0 ) {
    if ( c ) stream << ", " ;
    stream << "hy = " << (*hy)[i] ;
    c++ ;
  }
  if ( (*hz)[i] != 0 ) {
    if ( c ) stream << ", " ;
    stream << "hz = " << (*hz)[i] ;
    c++ ;
  }
  if ( (*Jx)[i] != 0 ) {
    if ( c ) stream << ", " ;
    stream << "Jx = " << (*Jx)[i] ;
    c++ ;
  }
  if ( (*Jy)[i] != 0 ) {
    if ( c ) stream << ", " ;
    stream << "Jy = " << (*Jy)[i] ;
    c++ ;
  }
  if ( (*Jz)[i] != 0 ) {
    if ( c ) stream << ", " ;
    stream << "Jz = " << (*Jz)[i] ;
  }
  if ( dt > 0 ) {
    stream << " (dt = " << dt << ")" ;
  }
  stream << std::endl ;
  return stream.str() ;

}


template <typename C, typename P>
void qasm( const C& circuit , const size_t i , const double dt ,
           const P* hx , const P* hy , const P* hz ,
           const P* Jx , const P* Jy , const P* Jz ,
           std::string filename ) {

  // generate qasm
  std::stringstream qasm ;
  circuit.toQASM( qasm ) ;

  // write to file
  filename.append( std::to_string( i+1 ) ) ;
  filename.append( ".qasm" ) ;
  std::ofstream stream( filename ) ;
  const int N = circuit.nbQubits() ;
  stream << "// Generated by f3c++\n"
         << "// https://github.com/QuantumComputingLab/f3cpp\n\n"
         << "// " << printTimestep( i , hx , hy , hz , Jx , Jy , Jz , dt )
         << "\n\n"
         << "OPENQASM 2.0;\n"
         << "include \"qelib1.inc\";\n\n"
         << "qreg q[" << N << "];\n"
         << qasm.str() ;
  stream.close() ;

}


template <typename F, typename P = f3c::Param< double >>
int timeEvolution( const int N , const int ntot , const double dt ,
                   const int imin , const int imax , const int step ,
                   const P* hx , const P* hy , const P* hz ,
                   const P* Jx , const P* Jy , const P* Jz ,
                   const std::string filename = std::string( "out" ) ,
                   const int debug = 0 ) {

  using G = typename F::gate_type ;
  using T = typename F::value_type ;
  using R = qclab::real_t< T > ;

  // quantum circuit
  qclab::QCircuit< T , G >  circuit( N ) ;
  qclab::QCircuit< T , G >  tmpcircuit( N ) ;

  // 1 timestep circuit
  size_t nbGates1 = N/2 ;
  size_t nbGates2 = (N-1)/2 ;
  qclab::QCircuit< T , G >  circ1( N , 0 , N-1 ) ;
  qclab::QCircuit< T , G >  tmpcirc1( N , 0 , N-1 ) ;

  // build circuit
  size_t out = imin ;
  if ( ntot <= N/2 ) {
    // loop over timesteps
    for ( size_t i = 0; i < ntot; i++ ) {
      std::cout << "* " << printTimestep( i , hx , hy , hz , Jx , Jy , Jz ) ;
      F::template timestep( dt , (*hx)[i] , (*hy)[i] , (*hz)[i] ,
                                 (*Jx)[i] , (*Jy)[i] , (*Jz)[i] , circ1 ) ;
      for ( size_t j = 0; j < N-1; j++ ) {
        circuit.push_back( std::move( circ1[j] ) ) ;
      }
      // output
      if ( out == i+1 && i+1 <= imax ) {
        qasm( circuit , i , dt , hx , hy , hz , Jx , Jy , Jz , filename ) ;
        out += step ;
      }
    }
  } else {
    //
    // square circuit
    f3c::SquareCircuit< T , G > square( N ) ;
    for ( size_t i = 0; i < N/2; i++ ) {
      std::cout << "* " << printTimestep( i , hx , hy , hz , Jx , Jy , Jz ) ;
      F::template timestep( dt , (*hx)[i] , (*hy)[i] , (*hz)[i] ,
                                 (*Jx)[i] , (*Jy)[i] , (*Jz)[i] , circ1 ) ;
      #pragma omp parallel for
      for ( size_t j = 0; j < N-1; j++ ) {
        square[ j + (N-1)*i ] = std::move( circ1[j] ) ;
      }
      // debug
      if ( debug ) {
        F::template timestep( dt , (*hx)[i] , (*hy)[i] , (*hz)[i] ,
                                   (*Jx)[i] , (*Jy)[i] , (*Jz)[i] , tmpcirc1 ) ;
        for ( size_t j = 0; j < N-1; j++ ) {
          tmpcircuit.push_back( std::move( tmpcirc1[j] ) ) ;
        }
      }
      // output
      if ( out == i+1 && i+1 <= imax ) {
        qclab::QCircuit< T , G >  tmpsquare( N , 0 , (i+1)*(N-1) ) ;
        for ( size_t k = 0; k < (i+1)*(N-1); k++ ) {
          auto gate = *square[k] ;
          tmpsquare[k] = std::make_unique< decltype( gate ) >( gate ) ;
        }
        qasm( tmpsquare , i , dt , hx , hy , hz , Jx , Jy , Jz , filename ) ;
        out += step ;
      }
    }
    // odd number of qubits
    if ( N % 2 != 0 ) {
      const size_t i = N/2 ;
      std::cout << "* " << printTimestep( i , hx , hy , hz , Jx , Jy , Jz ) ;
      F::template timestep( dt , (*hx)[i] , (*hy)[i] , (*hz)[i] ,
                                 (*Jx)[i] , (*Jy)[i] , (*Jz)[i] , circ1 ) ;
      #pragma omp parallel for
      for ( size_t j = 0; j < N/2; j++ ) {
        square[ j + (N-1)*i ] = std::move( circ1[j] ) ;
      }
      // debug
      if ( debug ) {
        F::template timestep( dt , (*hx)[i] , (*hy)[i] , (*hz)[i] ,
                                   (*Jx)[i] , (*Jy)[i] , (*Jz)[i] , tmpcirc1 ) ;
        for ( size_t j = 0; j < N-1; j++ ) {
          tmpcircuit.push_back( std::move( tmpcirc1[j] ) ) ;
        }
      }
    }
    //
    // square --> triangle
    auto triangle = square.toTriangle() ;
    // odd number of qubits
    if ( N % 2 != 0 ) {
      std::printf( "    - merge layer2\n" ) ;
      #pragma omp parallel for
      for ( size_t j = N/2; j < N-1; j++ ) {
        triangle.merge( qclab::Side::Right , circ1[j] ) ;
      }
      // output
      if ( out == N/2+1 && N/2+1 <= imax ) {
        f3c::TriangleCircuit< T , G >  tmptriangle( triangle ) ;
        circuit = tmptriangle.toSquare() ;
        qasm( circuit , N/2 , dt , hx , hy , hz , Jx , Jy , Jz , filename ) ;
        out += step ;
        if ( debug ) std::printf( "  --> nrmF = %.4e\n" ,
                                  qclab::nrmF( circuit , tmpcircuit ) ) ;
      }
    }
    //
    // merge timesteps
    for ( int i = (N+1)/2; i < ntot; i++ ) {
      std::cout << "* " << printTimestep( i , hx , hy , hz , Jx , Jy , Jz ) ;
      F::template timestep( dt , (*hx)[i] , (*hy)[i] , (*hz)[i] ,
                                 (*Jx)[i] , (*Jy)[i] , (*Jz)[i] , circ1 ) ;
      std::printf( "    - merge layer1\n" ) ;
      #pragma omp parallel for
      for ( size_t j = 0; j < N/2; j++ ) {
        triangle.merge( qclab::Side::Right , circ1[j] ) ;
      }
      std::printf( "    - merge layer2\n" ) ;
      #pragma omp parallel for
      for ( size_t j = N/2; j < N-1; j++ ) {
        triangle.merge( qclab::Side::Right , circ1[j] ) ;
      }
      // debug
      if ( debug ) {
        F::template timestep( dt , (*hx)[i] , (*hy)[i] , (*hz)[i] ,
                                   (*Jx)[i] , (*Jy)[i] , (*Jz)[i] , tmpcirc1 ) ;
        for ( size_t j = 0; j < N-1; j++ ) {
          tmpcircuit.push_back( std::move( tmpcirc1[j] ) ) ;
        }
      }
      // output
      if ( out == i+1 && i+1 <= imax ) {
        f3c::TriangleCircuit< T , G >  tmptriangle( triangle ) ;
        circuit = tmptriangle.toSquare() ;
        qasm( circuit , i , dt , hx , hy , hz , Jx , Jy , Jz , filename ) ;
        out += step ;
        if ( debug ) std::printf( "  --> nrmF = %.4e\n" ,
                                  qclab::nrmF( circuit , tmpcircuit ) ) ;
      }
    }
    //
    // triangle --> square
    circuit = triangle.toSquare() ;
  }

  std::cout << std::endl ;
  if ( debug > 1 ) {
    qclab::printMatrix( circuit.matrix() ) ;
    std::cout << std::endl ;
  }

  // successful
  return 0 ;

}

